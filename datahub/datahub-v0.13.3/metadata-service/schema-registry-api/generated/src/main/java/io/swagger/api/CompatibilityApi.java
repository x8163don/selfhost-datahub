/**
 * NOTE: This class is auto generated by the swagger code generator program (3.0.33).
 * https://github.com/swagger-api/swagger-codegen Do not edit the class manually.
 */
package io.swagger.api;

import com.fasterxml.jackson.databind.ObjectMapper;
import io.datahubproject.schema_registry.openapi.generated.CompatibilityCheckResponse;
import io.datahubproject.schema_registry.openapi.generated.ErrorMessage;
import io.datahubproject.schema_registry.openapi.generated.RegisterSchemaRequest;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import java.io.IOException;
import java.util.Optional;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

@jakarta.annotation.Generated(
    value = "io.swagger.codegen.v3.generators.java.SpringCodegen",
    date = "2022-12-20T16:52:36.517693Z[Europe/Lisbon]")
@Validated
public interface CompatibilityApi {

  Logger log = LoggerFactory.getLogger(CompatibilityApi.class);

  default Optional<ObjectMapper> getObjectMapper() {
    return Optional.empty();
  }

  default Optional<HttpServletRequest> getRequest() {
    return Optional.empty();
  }

  default Optional<String> getAcceptHeader() {
    return getRequest().map(r -> r.getHeader("Accept"));
  }

  @Operation(
      summary = "Test schema compatibility against a particular schema subject-version",
      description =
          "Test input schema against a particular version of a subject's schema for compatibility. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).",
      tags = {"Compatibility (v1)"})
  @ApiResponses(
      value = {
        @ApiResponse(
            responseCode = "200",
            description = "Compatibility check result.",
            content =
                @Content(
                    mediaType = "application/vnd.schemaregistry.v1+json",
                    schema =
                        @io.swagger.v3.oas.annotations.media.Schema(
                            implementation = CompatibilityCheckResponse.class))),
        @ApiResponse(
            responseCode = "404",
            description =
                "Not Found. Error code 40401 indicates subject not found. Error code 40402 indicates version not found.",
            content =
                @Content(
                    mediaType = "application/vnd.schemaregistry.v1+json",
                    schema =
                        @io.swagger.v3.oas.annotations.media.Schema(
                            implementation = ErrorMessage.class))),
        @ApiResponse(
            responseCode = "422",
            description =
                "Unprocessable entity. Error code 42201 indicates an invalid schema or schema type. Error code 42202 indicates an invalid version.",
            content =
                @Content(
                    mediaType = "application/vnd.schemaregistry.v1+json",
                    schema =
                        @io.swagger.v3.oas.annotations.media.Schema(
                            implementation = ErrorMessage.class))),
        @ApiResponse(
            responseCode = "500",
            description =
                "Internal Server Error. Error code 50001 indicates a failure in the backend data store.",
            content =
                @Content(
                    mediaType = "application/vnd.schemaregistry.v1+json",
                    schema =
                        @io.swagger.v3.oas.annotations.media.Schema(
                            implementation = ErrorMessage.class)))
      })
  @RequestMapping(
      value = "/compatibility/subjects/{subject}/versions/{version}",
      produces = {
        "application/vnd.schemaregistry.v1+json",
        "application/vnd.schemaregistry+json; qs=0.9",
        "application/json; qs=0.5"
      },
      consumes = {
        "application/vnd.schemaregistry.v1+json",
        "application/vnd.schemaregistry+json",
        "application/json",
        "application/octet-stream"
      },
      method = RequestMethod.POST)
  default ResponseEntity<CompatibilityCheckResponse> testCompatibilityBySubjectName(
      @Parameter(
              in = ParameterIn.PATH,
              description =
                  "Subject of the schema version against which compatibility is to be tested",
              required = true,
              schema = @io.swagger.v3.oas.annotations.media.Schema())
          @PathVariable("subject")
          String subject,
      @Parameter(
              in = ParameterIn.PATH,
              description =
                  "Version of the subject's schema against which compatibility is to be tested. Valid values for versionId are between [1,2^31-1] or the string \"latest\".\"latest\" checks compatibility of the input schema with the last registered schema under the specified subject",
              required = true,
              schema = @io.swagger.v3.oas.annotations.media.Schema())
          @PathVariable("version")
          String version,
      @Parameter(
              in = ParameterIn.DEFAULT,
              description = "Schema",
              required = true,
              schema = @io.swagger.v3.oas.annotations.media.Schema())
          @Valid
          @RequestBody
          RegisterSchemaRequest body,
      @Parameter(
              in = ParameterIn.QUERY,
              description = "Whether to return detailed error messages",
              schema = @io.swagger.v3.oas.annotations.media.Schema())
          @Valid
          @RequestParam(value = "verbose", required = false)
          Boolean verbose) {
    if (getObjectMapper().isPresent() && getAcceptHeader().isPresent()) {
      if (getAcceptHeader().get().contains("application/json")) {
        try {
          return new ResponseEntity<>(
              getObjectMapper()
                  .get()
                  .readValue(
                      "{\n  \"is_compatible\" : true,\n  \"messages\" : [ ]\n}",
                      CompatibilityCheckResponse.class),
              HttpStatus.NOT_IMPLEMENTED);
        } catch (IOException e) {
          log.error("Couldn't serialize response for content type application/json", e);
          return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
      }
    } else {
      log.warn(
          "ObjectMapper or HttpServletRequest not configured in default CompatibilityApi interface so no example is generated");
    }
    return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);
  }

  @Operation(
      summary = "Test schema compatibility against all schemas under a subject",
      description =
          "Test input schema against a subject's schemas for compatibility, based on the configured compatibility level of the subject. In other words, it will perform the same compatibility check as register for that subject. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).",
      tags = {"Compatibility (v1)"})
  @ApiResponses(
      value = {
        @ApiResponse(
            responseCode = "200",
            description = "Compatibility check result.",
            content =
                @Content(
                    mediaType = "application/vnd.schemaregistry.v1+json",
                    schema =
                        @io.swagger.v3.oas.annotations.media.Schema(
                            implementation = CompatibilityCheckResponse.class))),
        @ApiResponse(
            responseCode = "422",
            description =
                "Unprocessable Entity. Error code 42201 indicates an invalid schema or schema type. Error code 42202 indicates an invalid version.",
            content =
                @Content(
                    mediaType = "application/vnd.schemaregistry.v1+json",
                    schema =
                        @io.swagger.v3.oas.annotations.media.Schema(
                            implementation = ErrorMessage.class))),
        @ApiResponse(
            responseCode = "500",
            description =
                "Internal Server Error. Error code 50001 indicates a failure in the backend data store.",
            content =
                @Content(
                    mediaType = "application/vnd.schemaregistry.v1+json",
                    schema =
                        @io.swagger.v3.oas.annotations.media.Schema(
                            implementation = ErrorMessage.class)))
      })
  @RequestMapping(
      value = "/compatibility/subjects/{subject}/versions",
      produces = {
        "application/vnd.schemaregistry.v1+json",
        "application/vnd.schemaregistry+json; qs=0.9",
        "application/json; qs=0.5"
      },
      consumes = {
        "application/vnd.schemaregistry.v1+json",
        "application/vnd.schemaregistry+json",
        "application/json",
        "application/octet-stream"
      },
      method = RequestMethod.POST)
  default ResponseEntity<CompatibilityCheckResponse> testCompatibilityForSubject(
      @Parameter(
              in = ParameterIn.PATH,
              description =
                  "Subject of the schema version against which compatibility is to be tested",
              required = true,
              schema = @io.swagger.v3.oas.annotations.media.Schema())
          @PathVariable("subject")
          String subject,
      @Parameter(
              in = ParameterIn.DEFAULT,
              description = "Schema",
              required = true,
              schema = @io.swagger.v3.oas.annotations.media.Schema())
          @Valid
          @RequestBody
          RegisterSchemaRequest body,
      @Parameter(
              in = ParameterIn.QUERY,
              description = "Whether to return detailed error messages",
              schema = @io.swagger.v3.oas.annotations.media.Schema())
          @Valid
          @RequestParam(value = "verbose", required = false)
          Boolean verbose) {
    if (getObjectMapper().isPresent() && getAcceptHeader().isPresent()) {
      if (getAcceptHeader().get().contains("application/json")) {
        try {
          return new ResponseEntity<>(
              getObjectMapper()
                  .get()
                  .readValue(
                      "{\n  \"is_compatible\" : true,\n  \"messages\" : [ ]\n}",
                      CompatibilityCheckResponse.class),
              HttpStatus.NOT_IMPLEMENTED);
        } catch (IOException e) {
          log.error("Couldn't serialize response for content type application/json", e);
          return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
      }
    } else {
      log.warn(
          "ObjectMapper or HttpServletRequest not configured in default CompatibilityApi interface so no example is generated");
    }
    return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);
  }
}
